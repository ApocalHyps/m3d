M3D

31/03
Premiere pas :
Découverte de la sdl.
SDL_INIT et les Quit pour eviter les fuites de mémoire.
Logging
Création d'une fenetre simple et initilaisation du renderer (dessins de points et de lignes)
Dans le main


01/04

création des objets vecteur 2d, 3d et matrice 2d 3d 

Création de l'objet camera

Création de la méthode normalize3d qui renvoi un vect coll au vecteur passé mais normalizé

Création d'un générateur de vecteur qui forment la caméra avec pour le moment un vecteur par pixel sur un angle de vue (FOV) réglable (70° pour les tests)

Création pour le test d'un matrice de rotation sur Z pour faire bouger la caméra
Test concluant qui a mené a la crétion de la matrice de rotation de la caméra qui est une composition précise de 3 angle permtant d'orienter la caméra.

Création alors de la méthode RotatePointsEcran qui prend un ensemble de vecteur3d et leur applique les rotation sucessive : phi selon Z, theta selon x' et gamma selon y'' représentant phi : regard gauche droit theta regardhaut bas et gamma regard penché.

Test dans le main d'un bout de code permettant de tester le tracé des rayon. La scène ne présente qu'une sphère.
On obitent bien un sphère et un fond noir.

/--------------------------------/
L'idée est maintenant de creer un ensemble d'objet qui composeront une scène et d'être capable d'iterer sur l'ensemble des éléments de la scène. Peut etre instancier les objets de meme type pour leur attribuer une fonction de distance passé par adresse. Ensuite creer des methode pour le renderer afin de cast les rayons et iterer sur chaque éléments de la scène.

Note pourri : ont pourrais caster les rayons en damier et si un rayon (pas cast) est entourer de 4 rayon qui sont aller a une certaine distance (ou trop loin), prendre le minimum comme point de départ (ou ne pas le cast mais c'est moyen comme idée). On risque de perdre u détail lointain

Note importante : Le facteur d ne semble pas impacterle champ de vue ce qui n'est pas normal

On normalise les vecteurs de Rays generer pour l'écran

On améliore le test dans le main en réécrivant les paramètres plus proprement.

Note : Pour le raymarching on poura se passer de la première itération et la faire une fois pour touts les rayons puisqu'ils provienne au premier coup du même point.

Ajout de la fonction dot qui a deux vecteur passé renvoi le produit scalair usuel dans le repère x,y,zp

02/04

Implémentation de la fonction reflect grace à : https://asawicki.info/news_1301_reflect_and_refract_functions.html
Prenant un vect3d incident par adresse et un vect3d normal à la surface et modifie le vecteur incident en vect réflechit.

Introduction des fonctions sphereNormal et planXY normal permettant de faire des vect normaux sans estimateNormal


03/04

Essai d'implémentation de plusieurs technique de shadow, simple ou phong, aucune ne semble fonctionner correctement je pense a un problème sur l'évalutaion de la normale

Effectivement il s'agit bien de la donction normale qui ne marche pas le phong fonctionne bien sur les sphere mais il semble quand même avoir des strates visible dont je ne connais pas l'origine

j'ai ajouté un tableau global spheres qui pourrais techniquement dans le future contenir l'ensemble des sphères de la scéne.

Ajout des fonctions norme et fonction necessaires aux différentes implémentation des shadows.

06/04

Après un week-end où je n'ai pas pu avancer je me lance dans la conception de la fonction de rendering : raymarcheRay qui se vera passer un position et une direction et devra modifier la couleur passer en fonction de ce que le rayon percoit de la scène.

Premièrement on va essayer de déplacer ce qu'il y a dans le main dans cette fonction.

08/04

Le problème était dans le normalize3d on multipliait par le module au lieux de diviser

Il en résult que le phong ne marche plus

Une implémentation plus simple semble marcher mais le test en animation sur une obucle for semble ridiculement lent en terme de fps. Sans delay le temps entre frames on était proche du 4 fps avec une unique sphère dans la scène.

On envosagera l'utilisation de threads on testera avec 16 thread grace au module pthread puisque'il semble impossible d'utiliser le GPU sans openGL ou Cuda.